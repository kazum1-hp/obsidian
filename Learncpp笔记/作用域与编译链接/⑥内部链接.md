在[[③局部变量#局部变量没有链接属性]]一节中，我们说过，“标识符的链接属性决定了该名称的其他声明是否引用同一对象”，同时也得知–局部变量没有链接属性。

具有内部链接的标识符可以在单个[[翻译单元]]内看到并使用，但它不能从其他翻译单元访问（即，它不向链接器公开）。这意味着，如果两个源文件具有具有内部链接的同名标识符，则这些标识符将被视为独立的（并且不会因具有重复定义而导致ODR冲突）。

# 为什么要费心为标识符提供内部链接？

让标识符具有内部链接通常有两个原因：

1. 有一个标识符，我们要确保其他文件无法访问。这可能是一个我们不想弄乱的全局变量，或者是一个不想调用的辅助函数。
2. 避免命名冲突。由于具有内部链接的标识符不会向链接器公开，因此它们只能与同一翻译单元中的名称发生冲突，而不会在整个程序中发生冲突。

许多现代开发指南建议，不打算在其它文件中访问的变量或函数，都设置为内部链接。如果你可以完全遵守，这是一个很好的建议。

当然，有一个更为轻量级的准则：将有明确理由不允许从其他文件访问的任何标识符设置为内部链接。


> [!NOTE] 最佳实践
> - 当您有明确的理由不允许从其他文件访问时，将标识符设置为内部链接。
> - 最好将您不希望其他文件访问的所有标识符设置为内部链接（使用未命名的命名空间）。

# 快速摘要

```C++
// 全局变量 内部链接 定义:
static int g_x;          // 定义未初始化的 内部全局变量 (默认初始化为0)
static int g_x{ 1 };     // 定义初始化了的 内部全局变量

const int g_y { 2 };     // 定义初始化了的 const 内部全局变量
constexpr int g_y { 3 }; // 定义初始化了的 constexpr 内部全局变量

// 函数 内部链接 定义:
static int foo() {};     // 定义 内部 函数
```