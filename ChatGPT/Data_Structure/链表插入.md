
![[QQ图片20250427161840.png]]

---

这段代码的功能是：  
**在链表的第 n 个位置插入一个新节点**。  
（注意：`n` 是从 1 开始数的，不是从 0 开始哦。）

---

🌸 具体步骤解析：

1. `Node* temp1 = new Node();`  
    — 创建一个新的节点 `temp1`。
    
2. `temp1->data = data;`  
    — 把新节点的 `data` 填好。
    
3. `temp1->next = NULL;`  
    — 先让新节点的 `next` 为空（防止指向奇怪的东西）。
    

---

4. `if (n == 1)`  
    如果插入的位置是第 1 个（也就是**头部插入**）：
    
    - `temp1->next = head;`  
        新节点的 `next` 指向原来的头节点。
        
    - `head = temp1;`  
        头指针 `head` 更新为新节点。
        
    - `return;`  
        完成，直接返回，不用继续下面的步骤了。
        


---

5. 其他情况（n > 1）：
    
    - `Node* temp2 = head;`  
        新建一个指针 `temp2`，从头开始。
        
    - `for (int i = 0; i < n-2; i++) temp2 = temp2->next;`  
        让 `temp2` 走 `n-2` 步，停在**第 (n-1) 个节点**上。  
        （因为我们要在第 `n-1` 个节点后面插入。）
        

---

6. 插入操作：
    
    - `temp1->next = temp2->next;`  
        新节点 `temp1` 的 `next` 指向第 `n` 个节点（也就是原来 `temp2` 的下一个节点）。
        
    - `temp2->next = temp1;`  
        第 `n-1` 个节点（`temp2`）的 `next` 改成指向新节点 `temp1`。
        

---

🎯 这样，链表的连接关系就改好了，新的节点插到了第 `n` 个位置上！

---

💬 简单举个例子，比如原来链表是：

```
head → A → B → C → D → null
```

如果你调用 `Insert(x, 3)`（在第 3 个位置插入一个 `x`）：

- `temp2` 走 `(3-2)=1` 步，到达 `A` 后的 `B`。
    
- 然后：
    

```
temp1(x) → C
B → temp1(x)
```

结果链表变成：

```
head → A → B → x → C → D → null
```

（有点像把 `x` 插到了 B 和 C 之间。）

---

