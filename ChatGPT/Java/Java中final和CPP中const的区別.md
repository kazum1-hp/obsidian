Java 的 final 和 C++ 的 const 虽然概念相似，但它们在语法、使用场景、功能限制等方面是有不少差异的。我们来详细对比一下，顺便也总结成一个表格方便你理解和记忆：

  

  

  

🧩 Java final vs C++ const 对比表：

|   |   |   |
|---|---|---|
|对比项|Java final|C++ const|
|修饰变量（基本类型）|值不可变（常量）|值不可变（常量）|
|修饰变量（引用类型）|引用地址不可变，对象内容可变|视情况：可以是指针常量，也可以是常量指针|
|修饰方法参数|方法内不能重新赋值|方法内不能修改值（如果是引用，也不能通过引用修改内容）|
|修饰方法|子类不能 override 这个方法|不适用（C++ 没有完全类似）|
|修饰类|不能被继承|用 final 关键字（C++11）才表示不可继承|
|修饰成员变量|必须在声明时或构造器中初始化|const 成员必须初始化，也可用 constexpr|
|数组可变性|final 数组的引用不能变，内容可以变|const 数组指针/内容不可变，看修饰位置|
|运行时 vs 编译时常量|final 是运行时常量|const 是编译时常量（但也有运行时 const）|

  

  

  

  

✅ 示例对比（看代码更直观）：

  

Java 示例：

final int x = 10;

final int[] arr = {1, 2, 3};

arr[0] = 99; // OK，内容可变

arr = new int[3]; // ❌ 错误，final不能重新赋值

C++ 示例：

const int x = 10;

int arr[] = {1, 2, 3};

const int* p = arr; // 指向常量的指针：*p 不可改，p 可改

int* const q = arr; // 常量指针：p 不可改，*p 可改

  

  

  

  

🧠 总结一句话：

  

Java 的 final 主要是“不能重新赋值”，而 C++ 的 const 更强调“不能被修改”，语义更丰富，也更细粒度。

  

  

  

如果你是从 C++ 转 Java，会发现 Java 的 final 没有那么强大；

如果你是从 Java 转 C++，会觉得 const 语法多变但也更灵活。

  

  

  

 