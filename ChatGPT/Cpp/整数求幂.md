```C++
std::int64_t result{ 1 };
	while (exp > 0)
	{
		if (exp & 1)  // 如果exp 为奇数
			result *= base;
		exp /= 2;
		base *= base;
	}

	return result;
```

这个循环实际上实现了**快速幂算法**（也叫“二进制指数算法”），用于高效计算 `base` 的 `exp` 次方。它通过将指数分解成二进制的形式，大大减少了计算次数。

### 快速幂的核心思想：
通过每次将指数 `exp` 减半，我们减少了乘法运算的次数。结合指数的奇偶性，快速确定在过程中需要乘入 `base` 的情况。

### 代码的执行逻辑：
1. **判断指数 `exp` 的奇偶性**：
   - `exp & 1` 是判断 `exp` 是否为奇数的经典方法。
     - 如果 `exp` 为奇数（即最低位为1），则我们将当前的 `base` 乘入 `result`，因为此时相当于我们在二进制分解中遇到了一个有效的乘数。
   
2. **指数减半**：
   - `exp /= 2`：这是将指数右移一位，意味着在下一步我们处理的就是指数的一半。
   
3. **基数平方**：
   - `base *= base`：我们将 `base` 自己平方，这是因为在指数右移的过程中，新的基数相当于原来的 `base` 的平方。例如，如果你之前乘了 `base^1`，那么接下来你要乘的是 `base^2`，依此类推。

### 举例说明：
假设我们要计算 `base^13`：

- 13 的二进制表示为 `1101`，即 `base^13 = base^1 * base^4 * base^8`。
- 初始化 `result = 1`。

#### 第一次循环：
- `exp = 13`，即二进制 `1101`，最低位是 1（奇数）。
- 于是 `result *= base`，此时 `result = base`。
- 然后 `base *= base`，`base` 变成 `base^2`。
- 接着 `exp /= 2`，`exp` 变成 6。

#### 第二次循环：
- `exp = 6`，二进制 `110`，最低位是 0（偶数）。
- 不更新 `result`。
- 然后 `base *= base`，`base` 变成 `base^4`。
- 接着 `exp /= 2`，`exp` 变成 3。

#### 第三次循环：
- `exp = 3`，二进制 `11`，最低位是 1（奇数）。
- `result *= base`，此时 `result = base * base^4`。
- 然后 `base *= base`，`base` 变成 `base^8`。
- 接着 `exp /= 2`，`exp` 变成 1。

#### 第四次循环：
- `exp = 1`，二进制 `1`，最低位是 1（奇数）。
- `result *= base`，此时 `result = base * base^4 * base^8`。
- 然后 `base *= base`，`base` 变成 `base^16`。
- 接着 `exp /= 2`，`exp` 变成 0，循环结束。

### 总结：
每次循环通过指数减半和基数平方，我们逐渐把指数分解成二进制表示，然后在每次遇到 `1` 时，将对应的 `base^2^n` 乘入 `result`。这种方法可以在时间复杂度为 `O(log n)` 的情况下计算 `base^exp`，相比于直接的逐次乘法 `O(n)`，效率大幅提高。

