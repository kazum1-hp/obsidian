这句话的核心在于理解 `constexpr` 函数的要求和限制，以及它在不同上下文中的行为。

### 关键点：
1. **`constexpr` 函数的要求**：
   - 一个 `constexpr` 函数承诺它的结果**可以**在编译时计算，但这并不意味着它在所有场合都必须在编译时计算。它可以在运行时求值，只要输入不是编译时常量。
   - 不过，**当一个 `constexpr` 函数被用于需要编译时常量的上下文时**（例如，定义数组大小），它**必须**能够在编译时成功计算。如果不能，那么编译会报错。

2. **常量上下文与非常量上下文**：
   - **常量上下文**（Constant Context）：在某些情况下，C++ 要求表达式的值在编译时确定，比如：
     - 数组大小
     - `constexpr` 变量初始化
     - 模板参数
   - **非常量上下文**（Non-Constant Context）：普通的程序运行时计算场景，比如函数调用时计算值，或者在程序执行过程中才知道的值。
     - 比如，`int x = square(5);`，这不需要在编译时求值，运行时计算就可以。

3. **为什么要在常量上下文中测试 `constexpr` 函数？**
   - `constexpr` 函数在非常量上下文中（例如普通的函数调用）可能会通过编译，即使它的实现实际上无法在编译时计算。例如，它可能包含一些只在运行时有效的代码（比如读取 I/O 或动态分配内存）。在这种情况下，编译器允许这个函数在运行时求值，而不要求在编译时计算。
   
   - **然而**，如果这个函数用在常量上下文（比如定义 `constexpr` 变量或常量表达式）中，编译器就必须确保它能够在编译时计算出结果。如果该函数包含无法在编译时处理的操作（例如，循环中调用运行时函数），编译器会报错。

### 举个例子：
```cpp
constexpr int square(int x) {
    return x * x;
}

int main() {
    int x = 5;
    int y = square(x);  // 这个可以在运行时求值，编译器允许。

    constexpr int z = square(4);  // 这个必须在编译时求值，因为是在常量上下文中。
}
```

在这个例子中：
- `square(x)` 在运行时计算是可以接受的，因为 `x` 是运行时的变量，这不要求编译时计算。
- `square(4)` 必须在编译时计算，因为它用于初始化 `constexpr` 变量 `z`。

如果我们修改 `square` 函数，加入无法在编译时求值的操作，比如：
```cpp
constexpr int square(int x) {
    if (x == 0) return 0;
    int y = rand();  // rand() 不能在编译时使用
    return x * x;
}
```
在非常量上下文中，这个函数可能仍然编译成功并在运行时调用 `rand()`。但是，如果你尝试在常量上下文中使用它：
```cpp
constexpr int z = square(4);  // 这里会报错
```
编译器会报错，因为 `rand()` 不能在编译时计算。因此，你需要在**常量上下文**中测试 `constexpr` 函数，以确保它能够满足编译时计算的要求。

### 结论：
这句话的原因是：在非常量上下文中，`constexpr` 函数可能使用运行时的代码路径而不会报错，但如果你要在常量上下文中使用它，它必须严格遵守编译时计算的规则。因此，为了确保一个 `constexpr` 函数真正符合编译时求值的要求，应该在常量上下文中进行测试。